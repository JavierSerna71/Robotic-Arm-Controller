CCS PCM C Compiler, Version 5.061, 56587               21-nov.-23 01:49

               Filename:   C:\Users\fran-\Desktop\COSAS DE JAVI\FAKIU\7 semestre\datos\ENCODER DEL BRAZO.lst

               ROM used:   1336 words (16%)
                           Largest free fragment is 2048
               RAM used:   42 (11%) at main() level
                           58 (16%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   4C3
0003:  NOP
.................... #INCLUDE <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA 45,29
0005:  DATA D2,27
0006:  DATA D2,1E
0007:  DATA 25,26
0008:  DATA 75,15
0009:  DATA D0,27
000A:  DATA D4,22
000B:  DATA BD,12
000C:  DATA CC,3A
000D:  DATA AA,06
000E:  DATA 0A,00
*
0025:  MOVF   48,W
0026:  XORWF  4A,W
0027:  ANDLW  80
0028:  MOVWF  4C
0029:  BTFSS  48.7
002A:  GOTO   030
002B:  COMF   47,F
002C:  COMF   48,F
002D:  INCF   47,F
002E:  BTFSC  03.2
002F:  INCF   48,F
0030:  BTFSS  4A.7
0031:  GOTO   037
0032:  COMF   49,F
0033:  COMF   4A,F
0034:  INCF   49,F
0035:  BTFSC  03.2
0036:  INCF   4A,F
0037:  MOVLW  10
0038:  MOVWF  4B
0039:  CLRF   77
003A:  CLRF   7A
003B:  RRF    48,F
003C:  RRF    47,F
003D:  BTFSS  03.0
003E:  GOTO   045
003F:  MOVF   49,W
0040:  ADDWF  77,F
0041:  BTFSC  03.0
0042:  INCF   7A,F
0043:  MOVF   4A,W
0044:  ADDWF  7A,F
0045:  RRF    7A,F
0046:  RRF    77,F
0047:  RRF    79,F
0048:  RRF    78,F
0049:  DECFSZ 4B,F
004A:  GOTO   03B
004B:  BTFSS  4C.7
004C:  GOTO   052
004D:  COMF   78,F
004E:  COMF   79,F
004F:  INCF   78,F
0050:  BTFSC  03.2
0051:  INCF   79,F
0052:  RETURN
0053:  MOVLW  8E
0054:  MOVWF  77
0055:  MOVF   46,W
0056:  MOVWF  78
0057:  MOVF   45,W
0058:  MOVWF  79
0059:  CLRF   7A
005A:  BTFSS  46.7
005B:  GOTO   061
005C:  COMF   78,F
005D:  COMF   79,F
005E:  INCF   79,F
005F:  BTFSC  03.2
0060:  INCF   78,F
0061:  MOVF   78,F
0062:  BTFSS  03.2
0063:  GOTO   06E
0064:  MOVF   79,W
0065:  MOVWF  78
0066:  CLRF   79
0067:  MOVLW  08
0068:  SUBWF  77,F
0069:  MOVF   78,F
006A:  BTFSS  03.2
006B:  GOTO   06E
006C:  CLRF   77
006D:  GOTO   077
006E:  BCF    03.0
006F:  BTFSC  78.7
0070:  GOTO   075
0071:  RLF    79,F
0072:  RLF    78,F
0073:  DECF   77,F
0074:  GOTO   06E
0075:  BTFSS  46.7
0076:  BCF    78.7
0077:  RETURN
0078:  MOVF   46,W
0079:  MOVWF  4D
007A:  MOVF   4A,W
007B:  XORWF  4D,F
007C:  BTFSS  4D.7
007D:  GOTO   083
007E:  BCF    03.2
007F:  BCF    03.0
0080:  BTFSC  46.7
0081:  BSF    03.0
0082:  GOTO   0B6
0083:  MOVF   46,W
0084:  MOVWF  4D
0085:  MOVF   49,W
0086:  MOVWF  4E
0087:  MOVF   45,W
0088:  SUBWF  4E,F
0089:  BTFSC  03.2
008A:  GOTO   091
008B:  BTFSS  4D.7
008C:  GOTO   0B6
008D:  MOVF   03,W
008E:  XORLW  01
008F:  MOVWF  03
0090:  GOTO   0B6
0091:  MOVF   4A,W
0092:  MOVWF  4E
0093:  MOVF   46,W
0094:  SUBWF  4E,F
0095:  BTFSC  03.2
0096:  GOTO   09D
0097:  BTFSS  4D.7
0098:  GOTO   0B6
0099:  MOVF   03,W
009A:  XORLW  01
009B:  MOVWF  03
009C:  GOTO   0B6
009D:  MOVF   4B,W
009E:  MOVWF  4E
009F:  MOVF   47,W
00A0:  SUBWF  4E,F
00A1:  BTFSC  03.2
00A2:  GOTO   0A9
00A3:  BTFSS  4D.7
00A4:  GOTO   0B6
00A5:  MOVF   03,W
00A6:  XORLW  01
00A7:  MOVWF  03
00A8:  GOTO   0B6
00A9:  MOVF   4C,W
00AA:  MOVWF  4E
00AB:  MOVF   48,W
00AC:  SUBWF  4E,F
00AD:  BTFSC  03.2
00AE:  GOTO   0B5
00AF:  BTFSS  4D.7
00B0:  GOTO   0B6
00B1:  MOVF   03,W
00B2:  XORLW  01
00B3:  MOVWF  03
00B4:  GOTO   0B6
00B5:  BCF    03.0
00B6:  RETURN
*
0112:  MOVF   45,W
0113:  BTFSC  03.2
0114:  GOTO   182
0115:  MOVWF  4D
0116:  MOVF   49,W
0117:  BTFSC  03.2
0118:  GOTO   182
0119:  ADDWF  4D,F
011A:  BTFSC  03.0
011B:  GOTO   123
011C:  MOVLW  7F
011D:  SUBWF  4D,F
011E:  BTFSS  03.0
011F:  GOTO   182
0120:  BTFSC  03.2
0121:  GOTO   182
0122:  GOTO   127
0123:  MOVLW  81
0124:  ADDWF  4D,F
0125:  BTFSC  03.0
0126:  GOTO   182
0127:  MOVF   4D,W
0128:  MOVWF  77
0129:  CLRF   78
012A:  CLRF   79
012B:  CLRF   7A
012C:  MOVF   46,W
012D:  MOVWF  51
012E:  BSF    51.7
012F:  MOVF   47,W
0130:  MOVWF  50
0131:  MOVF   48,W
0132:  MOVWF  4F
0133:  MOVLW  18
0134:  MOVWF  4D
0135:  CLRF   4E
0136:  BTFSS  4F.0
0137:  GOTO   150
0138:  MOVF   4C,W
0139:  ADDWF  7A,F
013A:  BTFSS  03.0
013B:  GOTO   142
013C:  INCF   79,F
013D:  BTFSS  03.2
013E:  GOTO   142
013F:  INCF   78,F
0140:  BTFSC  03.2
0141:  BSF    4E.7
0142:  MOVF   4B,W
0143:  ADDWF  79,F
0144:  BTFSS  03.0
0145:  GOTO   149
0146:  INCF   78,F
0147:  BTFSC  03.2
0148:  BSF    4E.7
0149:  MOVF   4A,W
014A:  MOVWF  47
014B:  BSF    47.7
014C:  MOVF   47,W
014D:  ADDWF  78,F
014E:  BTFSC  03.0
014F:  BSF    4E.7
0150:  RLF    4E,F
0151:  RRF    78,F
0152:  RRF    79,F
0153:  RRF    7A,F
0154:  RRF    51,F
0155:  RRF    50,F
0156:  RRF    4F,F
0157:  BCF    03.0
0158:  DECFSZ 4D,F
0159:  GOTO   135
015A:  MOVLW  01
015B:  ADDWF  77,F
015C:  BTFSC  03.0
015D:  GOTO   182
015E:  BTFSC  78.7
015F:  GOTO   167
0160:  RLF    51,F
0161:  RLF    7A,F
0162:  RLF    79,F
0163:  RLF    78,F
0164:  DECF   77,F
0165:  BTFSC  03.2
0166:  GOTO   182
0167:  BTFSS  51.7
0168:  GOTO   178
0169:  INCF   7A,F
016A:  BTFSS  03.2
016B:  GOTO   178
016C:  INCF   79,F
016D:  BTFSS  03.2
016E:  GOTO   178
016F:  INCF   78,F
0170:  BTFSS  03.2
0171:  GOTO   178
0172:  RRF    78,F
0173:  RRF    79,F
0174:  RRF    7A,F
0175:  INCF   77,F
0176:  BTFSC  03.2
0177:  GOTO   182
0178:  MOVF   46,W
0179:  MOVWF  4E
017A:  MOVF   4A,W
017B:  XORWF  4E,F
017C:  BTFSS  4E.7
017D:  GOTO   180
017E:  BSF    78.7
017F:  GOTO   186
0180:  BCF    78.7
0181:  GOTO   186
0182:  CLRF   77
0183:  CLRF   78
0184:  CLRF   79
0185:  CLRF   7A
*
0197:  MOVLW  80
0198:  BTFSC  03.1
0199:  XORWF  4A,F
019A:  CLRF   4F
019B:  CLRF   50
019C:  MOVF   46,W
019D:  MOVWF  4E
019E:  MOVF   4A,W
019F:  XORWF  4E,F
01A0:  MOVF   45,W
01A1:  BTFSC  03.2
01A2:  GOTO   287
01A3:  MOVWF  4D
01A4:  MOVWF  77
01A5:  MOVF   49,W
01A6:  BTFSC  03.2
01A7:  GOTO   290
01A8:  SUBWF  4D,F
01A9:  BTFSC  03.2
01AA:  GOTO   22C
01AB:  BTFSS  03.0
01AC:  GOTO   1EA
01AD:  MOVF   4A,W
01AE:  MOVWF  53
01AF:  BSF    53.7
01B0:  MOVF   4B,W
01B1:  MOVWF  52
01B2:  MOVF   4C,W
01B3:  MOVWF  51
01B4:  CLRF   50
01B5:  BCF    03.0
01B6:  RRF    53,F
01B7:  RRF    52,F
01B8:  RRF    51,F
01B9:  RRF    50,F
01BA:  DECFSZ 4D,F
01BB:  GOTO   1B4
01BC:  BTFSS  4E.7
01BD:  GOTO   1C1
01BE:  BSF    4F.0
01BF:  GOTO   2A4
01C0:  BCF    4F.0
01C1:  BCF    4D.0
01C2:  BSF    4F.4
01C3:  MOVLW  48
01C4:  MOVWF  04
01C5:  BCF    03.7
01C6:  GOTO   2B9
01C7:  BCF    4F.4
01C8:  BTFSC  4E.7
01C9:  GOTO   1D4
01CA:  BTFSS  4D.0
01CB:  GOTO   1DF
01CC:  RRF    53,F
01CD:  RRF    52,F
01CE:  RRF    51,F
01CF:  RRF    50,F
01D0:  INCF   77,F
01D1:  BTFSC  03.2
01D2:  GOTO   29F
01D3:  GOTO   1DF
01D4:  BTFSC  53.7
01D5:  GOTO   1E2
01D6:  BCF    03.0
01D7:  RLF    50,F
01D8:  RLF    51,F
01D9:  RLF    52,F
01DA:  RLF    53,F
01DB:  DECF   77,F
01DC:  BTFSC  03.2
01DD:  GOTO   29F
01DE:  GOTO   1D4
01DF:  BSF    4F.6
01E0:  GOTO   24C
01E1:  BCF    4F.6
01E2:  MOVF   46,W
01E3:  MOVWF  4E
01E4:  BTFSS  4E.7
01E5:  GOTO   1E8
01E6:  BSF    53.7
01E7:  GOTO   298
01E8:  BCF    53.7
01E9:  GOTO   298
01EA:  MOVF   49,W
01EB:  MOVWF  4D
01EC:  MOVWF  77
01ED:  MOVF   45,W
01EE:  SUBWF  4D,F
01EF:  MOVF   46,W
01F0:  MOVWF  53
01F1:  BSF    53.7
01F2:  MOVF   47,W
01F3:  MOVWF  52
01F4:  MOVF   48,W
01F5:  MOVWF  51
01F6:  CLRF   50
01F7:  BCF    03.0
01F8:  RRF    53,F
01F9:  RRF    52,F
01FA:  RRF    51,F
01FB:  RRF    50,F
01FC:  DECFSZ 4D,F
01FD:  GOTO   1F6
01FE:  BTFSS  4E.7
01FF:  GOTO   203
0200:  BSF    4F.1
0201:  GOTO   2A4
0202:  BCF    4F.1
0203:  BCF    4D.0
0204:  BSF    4F.5
0205:  MOVLW  4C
0206:  MOVWF  04
0207:  BCF    03.7
0208:  GOTO   2B9
0209:  BCF    4F.5
020A:  BTFSC  4E.7
020B:  GOTO   216
020C:  BTFSS  4D.0
020D:  GOTO   221
020E:  RRF    53,F
020F:  RRF    52,F
0210:  RRF    51,F
0211:  RRF    50,F
0212:  INCF   77,F
0213:  BTFSC  03.2
0214:  GOTO   29F
0215:  GOTO   221
0216:  BTFSC  53.7
0217:  GOTO   224
0218:  BCF    03.0
0219:  RLF    50,F
021A:  RLF    51,F
021B:  RLF    52,F
021C:  RLF    53,F
021D:  DECF   77,F
021E:  BTFSC  03.2
021F:  GOTO   29F
0220:  GOTO   216
0221:  BSF    4F.7
0222:  GOTO   24C
0223:  BCF    4F.7
0224:  MOVF   4A,W
0225:  MOVWF  4E
0226:  BTFSS  4E.7
0227:  GOTO   22A
0228:  BSF    53.7
0229:  GOTO   298
022A:  BCF    53.7
022B:  GOTO   298
022C:  MOVF   4A,W
022D:  MOVWF  53
022E:  BSF    53.7
022F:  MOVF   4B,W
0230:  MOVWF  52
0231:  MOVF   4C,W
0232:  MOVWF  51
0233:  BTFSS  4E.7
0234:  GOTO   239
0235:  BCF    53.7
0236:  BSF    4F.2
0237:  GOTO   2A4
0238:  BCF    4F.2
0239:  CLRF   50
023A:  BCF    4D.0
023B:  MOVLW  48
023C:  MOVWF  04
023D:  BCF    03.7
023E:  GOTO   2B9
023F:  BTFSC  4E.7
0240:  GOTO   262
0241:  MOVF   46,W
0242:  MOVWF  4E
0243:  BTFSS  4D.0
0244:  GOTO   24C
0245:  RRF    53,F
0246:  RRF    52,F
0247:  RRF    51,F
0248:  RRF    50,F
0249:  INCF   77,F
024A:  BTFSC  03.2
024B:  GOTO   29F
024C:  BTFSS  50.7
024D:  GOTO   25D
024E:  INCF   51,F
024F:  BTFSS  03.2
0250:  GOTO   25D
0251:  INCF   52,F
0252:  BTFSS  03.2
0253:  GOTO   25D
0254:  INCF   53,F
0255:  BTFSS  03.2
0256:  GOTO   25D
0257:  RRF    53,F
0258:  RRF    52,F
0259:  RRF    51,F
025A:  INCF   77,F
025B:  BTFSC  03.2
025C:  GOTO   29F
025D:  BTFSC  4F.6
025E:  GOTO   1E1
025F:  BTFSC  4F.7
0260:  GOTO   223
0261:  GOTO   281
0262:  MOVLW  80
0263:  XORWF  53,F
0264:  BTFSS  53.7
0265:  GOTO   26A
0266:  GOTO   2A4
0267:  MOVF   4A,W
0268:  MOVWF  4E
0269:  GOTO   277
026A:  MOVF   46,W
026B:  MOVWF  4E
026C:  MOVF   53,F
026D:  BTFSS  03.2
026E:  GOTO   277
026F:  MOVF   52,F
0270:  BTFSS  03.2
0271:  GOTO   277
0272:  MOVF   51,F
0273:  BTFSS  03.2
0274:  GOTO   277
0275:  CLRF   77
0276:  GOTO   298
0277:  BTFSC  53.7
0278:  GOTO   281
0279:  BCF    03.0
027A:  RLF    50,F
027B:  RLF    51,F
027C:  RLF    52,F
027D:  RLF    53,F
027E:  DECFSZ 77,F
027F:  GOTO   277
0280:  GOTO   29F
0281:  BTFSS  4E.7
0282:  GOTO   285
0283:  BSF    53.7
0284:  GOTO   298
0285:  BCF    53.7
0286:  GOTO   298
0287:  MOVF   49,W
0288:  MOVWF  77
0289:  MOVF   4A,W
028A:  MOVWF  53
028B:  MOVF   4B,W
028C:  MOVWF  52
028D:  MOVF   4C,W
028E:  MOVWF  51
028F:  GOTO   298
0290:  MOVF   45,W
0291:  MOVWF  77
0292:  MOVF   46,W
0293:  MOVWF  53
0294:  MOVF   47,W
0295:  MOVWF  52
0296:  MOVF   48,W
0297:  MOVWF  51
0298:  MOVF   53,W
0299:  MOVWF  78
029A:  MOVF   52,W
029B:  MOVWF  79
029C:  MOVF   51,W
029D:  MOVWF  7A
029E:  GOTO   2D7
029F:  CLRF   77
02A0:  CLRF   78
02A1:  CLRF   79
02A2:  CLRF   7A
02A3:  GOTO   2D7
02A4:  CLRF   50
02A5:  COMF   51,F
02A6:  COMF   52,F
02A7:  COMF   53,F
02A8:  COMF   50,F
02A9:  INCF   50,F
02AA:  BTFSS  03.2
02AB:  GOTO   2B2
02AC:  INCF   51,F
02AD:  BTFSS  03.2
02AE:  GOTO   2B2
02AF:  INCF   52,F
02B0:  BTFSC  03.2
02B1:  INCF   53,F
02B2:  BTFSC  4F.0
02B3:  GOTO   1C0
02B4:  BTFSC  4F.1
02B5:  GOTO   202
02B6:  BTFSC  4F.2
02B7:  GOTO   238
02B8:  GOTO   267
02B9:  MOVF   00,W
02BA:  ADDWF  51,F
02BB:  BTFSS  03.0
02BC:  GOTO   2C3
02BD:  INCF   52,F
02BE:  BTFSS  03.2
02BF:  GOTO   2C3
02C0:  INCF   53,F
02C1:  BTFSC  03.2
02C2:  BSF    4D.0
02C3:  DECF   04,F
02C4:  MOVF   00,W
02C5:  ADDWF  52,F
02C6:  BTFSS  03.0
02C7:  GOTO   2CB
02C8:  INCF   53,F
02C9:  BTFSC  03.2
02CA:  BSF    4D.0
02CB:  DECF   04,F
02CC:  MOVF   00,W
02CD:  BTFSS  00.7
02CE:  XORLW  80
02CF:  ADDWF  53,F
02D0:  BTFSC  03.0
02D1:  BSF    4D.0
02D2:  BTFSC  4F.4
02D3:  GOTO   1C7
02D4:  BTFSC  4F.5
02D5:  GOTO   209
02D6:  GOTO   23F
*
0308:  MOVLW  8E
0309:  MOVWF  77
030A:  MOVF   45,W
030B:  SUBWF  77,F
030C:  MOVF   46,W
030D:  MOVWF  79
030E:  MOVF   47,W
030F:  MOVWF  78
0310:  BSF    79.7
0311:  MOVF   77,F
0312:  BTFSC  03.2
0313:  GOTO   31F
0314:  BCF    03.0
0315:  MOVF   79,F
0316:  BTFSS  03.2
0317:  GOTO   31B
0318:  MOVF   78,F
0319:  BTFSC  03.2
031A:  GOTO   31F
031B:  RRF    79,F
031C:  RRF    78,F
031D:  DECFSZ 77,F
031E:  GOTO   314
031F:  BTFSS  46.7
0320:  GOTO   326
0321:  COMF   78,F
0322:  COMF   79,F
0323:  INCF   78,F
0324:  BTFSC  03.2
0325:  INCF   79,F
*
03E0:  MOVF   0B,W
03E1:  MOVWF  46
03E2:  BCF    0B.7
03E3:  BSF    03.5
03E4:  BSF    03.6
03E5:  BSF    0C.7
03E6:  BSF    0C.0
03E7:  NOP
03E8:  NOP
03E9:  BCF    03.5
03EA:  BCF    03.6
03EB:  BTFSC  46.7
03EC:  BSF    0B.7
03ED:  BTFSC  03.0
03EE:  GOTO   418
03EF:  BSF    03.6
03F0:  MOVF   0C,W
03F1:  ANDLW  7F
03F2:  BCF    03.6
03F3:  MOVWF  46
03F4:  BSF    03.6
03F5:  MOVF   0D,W
03F6:  BCF    03.6
03F7:  MOVWF  47
03F8:  BSF    03.6
03F9:  MOVF   0F,W
03FA:  BCF    03.6
03FB:  MOVWF  48
03FC:  MOVF   46,W
03FD:  BTFSS  0C.4
03FE:  GOTO   3FD
03FF:  MOVWF  19
0400:  MOVF   47,W
0401:  BSF    03.6
0402:  MOVWF  0D
0403:  BCF    03.6
0404:  MOVF   48,W
0405:  BSF    03.6
0406:  MOVWF  0F
0407:  BCF    03.6
0408:  MOVF   0B,W
0409:  MOVWF  49
040A:  BCF    0B.7
040B:  BSF    03.5
040C:  BSF    03.6
040D:  BSF    0C.7
040E:  BSF    0C.0
040F:  NOP
0410:  NOP
0411:  BCF    03.5
0412:  BCF    03.6
0413:  BTFSC  49.7
0414:  BSF    0B.7
0415:  DECFSZ 45,F
0416:  GOTO   418
0417:  GOTO   438
0418:  BSF    03.6
0419:  RLF    0C,W
041A:  RLF    0E,W
041B:  ANDLW  7F
041C:  BCF    03.6
041D:  MOVWF  46
041E:  BSF    03.6
041F:  MOVF   0D,W
0420:  BCF    03.6
0421:  MOVWF  47
0422:  BSF    03.6
0423:  MOVF   0F,W
0424:  BCF    03.6
0425:  MOVWF  48
0426:  MOVF   46,W
0427:  BTFSS  0C.4
0428:  GOTO   427
0429:  MOVWF  19
042A:  MOVF   47,W
042B:  BSF    03.6
042C:  MOVWF  0D
042D:  BCF    03.6
042E:  MOVF   48,W
042F:  BSF    03.6
0430:  MOVWF  0F
0431:  INCF   0D,F
0432:  BTFSC  03.2
0433:  INCF   0F,F
0434:  BCF    03.0
0435:  BCF    03.6
0436:  DECFSZ 45,F
0437:  GOTO   3E0
0438:  RETURN
0439:  CLRF   4D
043A:  MOVF   04,W
043B:  MOVWF  4C
043C:  BCF    4D.0
043D:  BTFSC  03.7
043E:  BSF    4D.0
043F:  SWAPF  46,W
0440:  IORLW  F0
0441:  MOVWF  48
0442:  ADDWF  48,F
0443:  ADDLW  E2
0444:  MOVWF  49
0445:  ADDLW  32
0446:  MOVWF  4B
0447:  MOVF   46,W
0448:  ANDLW  0F
0449:  ADDWF  49,F
044A:  ADDWF  49,F
044B:  ADDWF  4B,F
044C:  ADDLW  E9
044D:  MOVWF  4A
044E:  ADDWF  4A,F
044F:  ADDWF  4A,F
0450:  SWAPF  45,W
0451:  ANDLW  0F
0452:  ADDWF  4A,F
0453:  ADDWF  4B,F
0454:  RLF    4A,F
0455:  RLF    4B,F
0456:  COMF   4B,F
0457:  RLF    4B,F
0458:  MOVF   45,W
0459:  ANDLW  0F
045A:  ADDWF  4B,F
045B:  RLF    48,F
045C:  MOVLW  07
045D:  MOVWF  47
045E:  MOVLW  0A
045F:  ADDWF  4B,F
0460:  DECF   4A,F
0461:  BTFSS  03.0
0462:  GOTO   45F
0463:  ADDWF  4A,F
0464:  DECF   49,F
0465:  BTFSS  03.0
0466:  GOTO   463
0467:  ADDWF  49,F
0468:  DECF   48,F
0469:  BTFSS  03.0
046A:  GOTO   467
046B:  ADDWF  48,F
046C:  DECF   47,F
046D:  BTFSS  03.0
046E:  GOTO   46B
046F:  MOVLW  47
0470:  MOVWF  04
0471:  BCF    03.7
0472:  MOVLW  07
0473:  ANDWF  4C,W
0474:  BCF    4C.6
0475:  ADDWF  04,F
0476:  MOVLW  4B
0477:  SUBWF  04,W
0478:  BTFSC  03.2
0479:  BSF    4C.6
047A:  MOVF   00,W
047B:  MOVWF  77
047C:  BTFSS  03.2
047D:  GOTO   486
047E:  BTFSC  4C.6
047F:  GOTO   486
0480:  BTFSC  4C.4
0481:  GOTO   48E
0482:  BTFSC  4C.3
0483:  GOTO   486
0484:  MOVLW  20
0485:  GOTO   489
0486:  BSF    4C.3
0487:  BCF    4C.4
0488:  MOVLW  30
0489:  ADDWF  77,F
048A:  MOVF   77,W
048B:  BTFSS  0C.4
048C:  GOTO   48B
048D:  MOVWF  19
048E:  INCF   04,F
048F:  BTFSS  4C.6
0490:  GOTO   476
0491:  RETURN
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #USE DELAY(internal=8MHz) 
*
000F:  MOVLW  45
0010:  MOVWF  04
0011:  BCF    03.7
0012:  MOVF   00,W
0013:  BTFSC  03.2
0014:  GOTO   022
0015:  MOVLW  02
0016:  MOVWF  78
0017:  CLRF   77
0018:  DECFSZ 77,F
0019:  GOTO   018
001A:  DECFSZ 78,F
001B:  GOTO   017
001C:  MOVLW  97
001D:  MOVWF  77
001E:  DECFSZ 77,F
001F:  GOTO   01E
0020:  DECFSZ 00,F
0021:  GOTO   015
0022:  BCF    0A.3
0023:  BCF    0A.4
0024:  GOTO   52B (RETURN)
.................... #FUSES XT,NOPROTECT,NOWDT,NOBROWNOUT,PUT,NOLVP 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
04F8:  BCF    03.6
04F9:  CLRF   20
04FA:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <map_function.c> 
.................... /* #include <map_function.c> 
.................... * 
.................... * Creada por: Ing. Abiezer Hernandez O. 
.................... * Fecha de creacion: 12/05/2018 
.................... * Electronica y Circuitos 
.................... * 
.................... */ 
....................  
.................... double map(float valor, float entradaMin, float entradaMax, float salidaMin, float salidaMax) 
.................... { 
....................    return((((valor-entradaMin)*(salidaMax-salidaMin))/(entradaMax-entradaMin))+salidaMin); 
.................... } 
....................  
.................... unsigned long map16(int16 valor, int16 entradaMin, int16 entradaMax, int16 salidaMin, int16 salidaMax) 
.................... { 
....................    return((((valor-entradaMin)*(salidaMax-salidaMin))/(entradaMax-entradaMin))+salidaMin); 
.................... } 
....................  
.................... #use RS232(BAUD=9600,BITS=8,PARITY=N,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #define CLK input(pin_b0) 
.................... #define DT input(pin_b1) 
.................... int16 PWM,KP=2,KD=0; 
.................... signed long  LEYDECONTROL,PID_P,PID_D,PID_I,ERROR,ERROR1,set=500,POTE; 
.................... float INTEGRAL,KI=0.04; 
.................... void PID() 
.................... { 
....................    ERROR=set-POTE;  
*
00B7:  MOVF   3A,W
00B8:  SUBWF  38,W
00B9:  MOVWF  34
00BA:  MOVF   39,W
00BB:  MOVWF  35
00BC:  MOVF   3B,W
00BD:  BTFSS  03.0
00BE:  INCFSZ 3B,W
00BF:  SUBWF  35,F
....................    PID_P=KP*ERROR; 
00C0:  MOVF   29,W
00C1:  MOVWF  48
00C2:  MOVF   28,W
00C3:  MOVWF  47
00C4:  MOVF   35,W
00C5:  MOVWF  4A
00C6:  MOVF   34,W
00C7:  MOVWF  49
00C8:  CALL   025
00C9:  MOVF   79,W
00CA:  MOVWF  2F
00CB:  MOVF   78,W
00CC:  MOVWF  2E
....................    PID_D=(KD*((ERROR-ERROR1))); 
00CD:  MOVF   36,W
00CE:  SUBWF  34,W
00CF:  MOVWF  77
00D0:  MOVF   35,W
00D1:  MOVWF  7A
00D2:  MOVF   37,W
00D3:  BTFSS  03.0
00D4:  INCFSZ 37,W
00D5:  SUBWF  7A,F
00D6:  MOVF   77,W
00D7:  MOVWF  45
00D8:  MOVF   7A,W
00D9:  MOVWF  46
00DA:  MOVF   2B,W
00DB:  MOVWF  48
00DC:  MOVF   2A,W
00DD:  MOVWF  47
00DE:  MOVF   7A,W
00DF:  MOVWF  4A
00E0:  MOVF   77,W
00E1:  MOVWF  49
00E2:  CALL   025
00E3:  MOVF   79,W
00E4:  MOVWF  31
00E5:  MOVF   78,W
00E6:  MOVWF  30
....................     if(-175 < ERROR && ERROR < 175) 
00E7:  BTFSS  35.7
00E8:  GOTO   0F4
00E9:  MOVF   35,W
00EA:  SUBLW  FE
00EB:  BTFSC  03.0
00EC:  GOTO   2E0
00ED:  XORLW  FF
00EE:  BTFSS  03.2
00EF:  GOTO   0F4
00F0:  MOVF   34,W
00F1:  SUBLW  51
00F2:  BTFSC  03.0
00F3:  GOTO   2E0
00F4:  BTFSC  35.7
00F5:  GOTO   0FD
00F6:  MOVF   35,F
00F7:  BTFSS  03.2
00F8:  GOTO   2E0
00F9:  MOVF   34,W
00FA:  SUBLW  AE
00FB:  BTFSS  03.0
00FC:  GOTO   2E0
....................     {  
....................       INTEGRAL=INTEGRAL+(KI*ERROR); 
00FD:  MOVF   35,W
00FE:  MOVWF  46
00FF:  MOVF   34,W
0100:  MOVWF  45
0101:  CALL   053
0102:  MOVF   43,W
0103:  MOVWF  48
0104:  MOVF   42,W
0105:  MOVWF  47
0106:  MOVF   41,W
0107:  MOVWF  46
0108:  MOVF   40,W
0109:  MOVWF  45
010A:  MOVF   7A,W
010B:  MOVWF  4C
010C:  MOVF   79,W
010D:  MOVWF  4B
010E:  MOVF   78,W
010F:  MOVWF  4A
0110:  MOVF   77,W
0111:  MOVWF  49
*
0186:  BCF    03.1
0187:  MOVF   3F,W
0188:  MOVWF  48
0189:  MOVF   3E,W
018A:  MOVWF  47
018B:  MOVF   3D,W
018C:  MOVWF  46
018D:  MOVF   3C,W
018E:  MOVWF  45
018F:  MOVF   7A,W
0190:  MOVWF  4C
0191:  MOVF   79,W
0192:  MOVWF  4B
0193:  MOVF   78,W
0194:  MOVWF  4A
0195:  MOVF   77,W
0196:  MOVWF  49
*
02D7:  MOVF   7A,W
02D8:  MOVWF  3F
02D9:  MOVF   79,W
02DA:  MOVWF  3E
02DB:  MOVF   78,W
02DC:  MOVWF  3D
02DD:  MOVF   77,W
02DE:  MOVWF  3C
....................     } 
02DF:  GOTO   2E4
....................     else 
....................     { 
....................       INTEGRAL = 0; 
02E0:  CLRF   3F
02E1:  CLRF   3E
02E2:  CLRF   3D
02E3:  CLRF   3C
....................     } 
....................      if(-3 < ERROR && ERROR < 3) 
02E4:  BTFSS  35.7
02E5:  GOTO   2F1
02E6:  MOVF   35,W
02E7:  SUBLW  FE
02E8:  BTFSC  03.0
02E9:  GOTO   300
02EA:  XORLW  FF
02EB:  BTFSS  03.2
02EC:  GOTO   2F1
02ED:  MOVF   34,W
02EE:  SUBLW  FD
02EF:  BTFSC  03.0
02F0:  GOTO   300
02F1:  BTFSC  35.7
02F2:  GOTO   2FA
02F3:  MOVF   35,F
02F4:  BTFSS  03.2
02F5:  GOTO   300
02F6:  MOVF   34,W
02F7:  SUBLW  02
02F8:  BTFSS  03.0
02F9:  GOTO   300
....................     { 
....................       INTEGRAL = 0; 
02FA:  CLRF   3F
02FB:  CLRF   3E
02FC:  CLRF   3D
02FD:  CLRF   3C
....................       LEYDECONTROL=0; 
02FE:  CLRF   2D
02FF:  CLRF   2C
....................     } 
....................      
....................       PID_I=INTEGRAL; 
0300:  MOVF   3F,W
0301:  MOVWF  48
0302:  MOVF   3E,W
0303:  MOVWF  47
0304:  MOVF   3D,W
0305:  MOVWF  46
0306:  MOVF   3C,W
0307:  MOVWF  45
*
0326:  MOVF   79,W
0327:  MOVWF  33
0328:  MOVF   78,W
0329:  MOVWF  32
....................       LEYDECONTROL= PID_P+PID_D+PID_I; 
032A:  MOVF   30,W
032B:  ADDWF  2E,W
032C:  MOVWF  45
032D:  MOVF   2F,W
032E:  MOVWF  46
032F:  MOVF   31,W
0330:  BTFSC  03.0
0331:  INCFSZ 31,W
0332:  ADDWF  46,F
0333:  MOVF   32,W
0334:  ADDWF  45,W
0335:  MOVWF  2C
0336:  MOVF   46,W
0337:  MOVWF  2D
0338:  MOVF   33,W
0339:  BTFSC  03.0
033A:  INCFSZ 33,W
033B:  ADDWF  2D,F
....................        
....................     if (LEYDECONTROL >= 718.0){       
033C:  MOVF   2D,W
033D:  MOVWF  46
033E:  MOVF   2C,W
033F:  MOVWF  45
0340:  CALL   053
0341:  CLRF   48
0342:  MOVLW  80
0343:  MOVWF  47
0344:  MOVLW  33
0345:  MOVWF  46
0346:  MOVLW  88
0347:  MOVWF  45
0348:  MOVF   7A,W
0349:  MOVWF  4C
034A:  MOVF   79,W
034B:  MOVWF  4B
034C:  MOVF   78,W
034D:  MOVWF  4A
034E:  MOVF   77,W
034F:  MOVWF  49
0350:  CALL   078
0351:  BTFSC  03.0
0352:  GOTO   355
0353:  BTFSS  03.2
0354:  GOTO   359
....................      LEYDECONTROL = 718.0; 
0355:  MOVLW  02
0356:  MOVWF  2D
0357:  MOVLW  CE
0358:  MOVWF  2C
....................    } 
....................     if (LEYDECONTROL <= 0){        
0359:  BTFSC  2D.7
035A:  GOTO   362
035B:  MOVF   2D,F
035C:  BTFSS  03.2
035D:  GOTO   36E
035E:  MOVF   2C,W
035F:  SUBLW  00
0360:  BTFSS  03.0
0361:  GOTO   36E
....................      LEYDECONTROL = LEYDECONTROL*-1; 
0362:  MOVF   2D,W
0363:  MOVWF  48
0364:  MOVF   2C,W
0365:  MOVWF  47
0366:  MOVLW  FF
0367:  MOVWF  4A
0368:  MOVWF  49
0369:  CALL   025
036A:  MOVF   79,W
036B:  MOVWF  2D
036C:  MOVF   78,W
036D:  MOVWF  2C
....................     } 
....................     if (LEYDECONTROL >= 718.0){       
036E:  MOVF   2D,W
036F:  MOVWF  46
0370:  MOVF   2C,W
0371:  MOVWF  45
0372:  CALL   053
0373:  CLRF   48
0374:  MOVLW  80
0375:  MOVWF  47
0376:  MOVLW  33
0377:  MOVWF  46
0378:  MOVLW  88
0379:  MOVWF  45
037A:  MOVF   7A,W
037B:  MOVWF  4C
037C:  MOVF   79,W
037D:  MOVWF  4B
037E:  MOVF   78,W
037F:  MOVWF  4A
0380:  MOVF   77,W
0381:  MOVWF  49
0382:  CALL   078
0383:  BTFSC  03.0
0384:  GOTO   387
0385:  BTFSS  03.2
0386:  GOTO   38B
....................      LEYDECONTROL = 718.0; 
0387:  MOVLW  02
0388:  MOVWF  2D
0389:  MOVLW  CE
038A:  MOVWF  2C
....................    } 
....................     
....................       PWM=LEYDECONTROL; 
038B:  MOVF   2D,W
038C:  MOVWF  27
038D:  MOVF   2C,W
038E:  MOVWF  26
....................       ERROR1=ERROR; 
038F:  MOVF   35,W
0390:  MOVWF  37
0391:  MOVF   34,W
0392:  MOVWF  36
....................         
....................       if(set>POTE){ 
0393:  BTFSS  3B.7
0394:  GOTO   398
0395:  BTFSS  39.7
0396:  GOTO   3A4
0397:  GOTO   39A
0398:  BTFSC  39.7
0399:  GOTO   3AC
039A:  MOVF   3B,W
039B:  SUBWF  39,W
039C:  BTFSS  03.0
039D:  GOTO   3AC
039E:  BTFSS  03.2
039F:  GOTO   3A4
03A0:  MOVF   38,W
03A1:  SUBWF  3A,W
03A2:  BTFSC  03.0
03A3:  GOTO   3AC
....................       OUTPUT_BIT(PIN_D0,1); 
03A4:  BSF    08.0
03A5:  BSF    03.5
03A6:  BCF    08.0
....................       OUTPUT_BIT(PIN_D1,0); 
03A7:  BCF    03.5
03A8:  BCF    08.1
03A9:  BSF    03.5
03AA:  BCF    08.1
03AB:  BCF    03.5
....................       } 
....................       if(set<POTE){ 
03AC:  BTFSS  39.7
03AD:  GOTO   3B1
03AE:  BTFSS  3B.7
03AF:  GOTO   3BD
03B0:  GOTO   3B3
03B1:  BTFSC  3B.7
03B2:  GOTO   3C5
03B3:  MOVF   39,W
03B4:  SUBWF  3B,W
03B5:  BTFSS  03.0
03B6:  GOTO   3C5
03B7:  BTFSS  03.2
03B8:  GOTO   3BD
03B9:  MOVF   3A,W
03BA:  SUBWF  38,W
03BB:  BTFSC  03.0
03BC:  GOTO   3C5
....................       OUTPUT_BIT(PIN_D0,0); 
03BD:  BCF    08.0
03BE:  BSF    03.5
03BF:  BCF    08.0
....................       OUTPUT_BIT(PIN_D1,1); 
03C0:  BCF    03.5
03C1:  BSF    08.1
03C2:  BSF    03.5
03C3:  BCF    08.1
03C4:  BCF    03.5
....................       } 
....................       set_pwm1_duty(PWM+280); 
03C5:  MOVLW  18
03C6:  ADDWF  26,W
03C7:  MOVWF  45
03C8:  MOVF   27,W
03C9:  MOVWF  46
03CA:  MOVLW  01
03CB:  BTFSC  03.0
03CC:  MOVLW  02
03CD:  ADDWF  46,F
03CE:  RRF    46,F
03CF:  RRF    45,F
03D0:  RRF    46,F
03D1:  RRF    45,F
03D2:  RRF    46,F
03D3:  MOVF   45,W
03D4:  MOVWF  15
03D5:  RRF    46,F
03D6:  RRF    46,W
03D7:  ANDLW  30
03D8:  MOVWF  77
03D9:  MOVF   17,W
03DA:  ANDLW  CF
03DB:  IORWF  77,W
03DC:  MOVWF  17
03DD:  BCF    0A.3
03DE:  BCF    0A.4
03DF:  GOTO   535 (RETURN)
.................... } 
.................... void mostrar() 
.................... { 
.................... printf("ERROR=%Lu*POTE=%Lu*\r\n",ERROR,POTE); 
*
0492:  MOVLW  04
0493:  BSF    03.6
0494:  MOVWF  0D
0495:  MOVLW  00
0496:  MOVWF  0F
0497:  BCF    03.0
0498:  MOVLW  06
0499:  BCF    03.6
049A:  MOVWF  45
049B:  CALL   3E0
049C:  MOVLW  10
049D:  MOVWF  04
049E:  MOVF   35,W
049F:  MOVWF  46
04A0:  MOVF   34,W
04A1:  MOVWF  45
04A2:  CALL   439
04A3:  MOVLW  08
04A4:  BSF    03.6
04A5:  MOVWF  0D
04A6:  MOVLW  00
04A7:  MOVWF  0F
04A8:  BSF    03.0
04A9:  MOVLW  06
04AA:  BCF    03.6
04AB:  MOVWF  45
04AC:  CALL   3E0
04AD:  MOVLW  10
04AE:  MOVWF  04
04AF:  MOVF   3B,W
04B0:  MOVWF  46
04B1:  MOVF   3A,W
04B2:  MOVWF  45
04B3:  CALL   439
04B4:  MOVLW  2A
04B5:  BTFSS  0C.4
04B6:  GOTO   4B5
04B7:  MOVWF  19
04B8:  MOVLW  0D
04B9:  BTFSS  0C.4
04BA:  GOTO   4B9
04BB:  MOVWF  19
04BC:  MOVLW  0A
04BD:  BTFSS  0C.4
04BE:  GOTO   4BD
04BF:  MOVWF  19
04C0:  BCF    0A.3
04C1:  BCF    0A.4
04C2:  GOTO   536 (RETURN)
.................... } 
....................  
.................... void main() 
04C3:  MOVF   03,W
04C4:  ANDLW  1F
04C5:  MOVWF  03
04C6:  MOVLW  71
04C7:  BSF    03.5
04C8:  MOVWF  0F
04C9:  CLRF   10
04CA:  MOVF   0F,W
04CB:  BSF    03.6
04CC:  BCF    07.3
04CD:  MOVLW  0C
04CE:  BCF    03.6
04CF:  MOVWF  19
04D0:  MOVLW  A2
04D1:  MOVWF  18
04D2:  MOVLW  90
04D3:  BCF    03.5
04D4:  MOVWF  18
04D5:  CLRF   29
04D6:  MOVLW  02
04D7:  MOVWF  28
04D8:  CLRF   2B
04D9:  CLRF   2A
04DA:  MOVLW  01
04DB:  MOVWF  39
04DC:  MOVLW  F4
04DD:  MOVWF  38
04DE:  MOVLW  0A
04DF:  MOVWF  43
04E0:  MOVLW  D7
04E1:  MOVWF  42
04E2:  MOVLW  23
04E3:  MOVWF  41
04E4:  MOVLW  7A
04E5:  MOVWF  40
04E6:  MOVLW  FF
04E7:  MOVWF  44
04E8:  BSF    03.5
04E9:  BSF    03.6
04EA:  MOVF   09,W
04EB:  ANDLW  C0
04EC:  MOVWF  09
04ED:  BCF    03.6
04EE:  BCF    1F.4
04EF:  BCF    1F.5
04F0:  MOVLW  00
04F1:  BSF    03.6
04F2:  MOVWF  08
04F3:  BCF    03.5
04F4:  CLRF   07
04F5:  CLRF   08
04F6:  CLRF   09
04F7:  BCF    03.7
.................... { 
....................    setup_timer_2(t2_div_by_1,255,1); 
*
04FB:  MOVLW  00
04FC:  MOVWF  78
04FD:  IORLW  04
04FE:  MOVWF  12
04FF:  MOVLW  FF
0500:  BSF    03.5
0501:  MOVWF  12
....................    setup_ccp1(ccp_pwm); 
0502:  BCF    03.5
0503:  BCF    44.2
0504:  MOVF   44,W
0505:  BSF    03.5
0506:  MOVWF  07
0507:  BCF    03.5
0508:  BCF    07.2
0509:  MOVLW  0C
050A:  MOVWF  17
050B:  BSF    03.5
050C:  CLRF   1B
050D:  CLRF   1C
050E:  MOVLW  01
050F:  MOVWF  1D
....................    setup_adc_ports(sAN0); 
0510:  BSF    03.6
0511:  MOVF   09,W
0512:  ANDLW  C0
0513:  MOVWF  09
0514:  BCF    03.6
0515:  BCF    1F.4
0516:  BCF    1F.5
0517:  MOVLW  01
0518:  BSF    03.6
0519:  MOVWF  08
....................    setup_adc(ADC_CLOCK_INTERNAL); 
051A:  BCF    03.5
051B:  BCF    03.6
051C:  BSF    1F.6
051D:  BSF    1F.7
051E:  BSF    03.5
051F:  BSF    1F.7
0520:  BCF    03.5
0521:  BSF    1F.0
....................    while(TRUE) 
....................    { 
....................       set_adc_channel(0); 
0522:  MOVLW  00
0523:  MOVWF  78
0524:  MOVF   1F,W
0525:  ANDLW  C3
0526:  IORWF  78,W
0527:  MOVWF  1F
....................       DELAY_MS(1); 
0528:  MOVLW  01
0529:  MOVWF  45
052A:  GOTO   00F
....................       POTE = read_adc(); 
052B:  BSF    1F.1
052C:  BTFSC  1F.1
052D:  GOTO   52C
052E:  BSF    03.5
052F:  MOVF   1E,W
0530:  BCF    03.5
0531:  MOVWF  3A
0532:  MOVF   1E,W
0533:  MOVWF  3B
....................       PID(); 
0534:  GOTO   0B7
....................       mostrar(); 
0535:  GOTO   492
0536:  GOTO   522
....................        
....................    } 
....................  
.................... } 
0537:  SLEEP

Configuration Fuses:
   Word  1: 2CE1   XT NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
